# Grading Queue: A Redis-based Architecture

The GradingQueue is ephemeral in nature, where data is stored and deleted only when jobs are in the grading queue. Thus Redis was the chosen tool to implement the Grading Queue in, as an in-memory storage system with quick access to its elements.

## Data Definitions

A full implementation of the grading queue requires three pieces of functionality:

1. Knowing when a job is ready to be extracted and graded.
2. Retrieving the next submission to be graded for a given team or user.
3. Obtaining the `GradingJob` object for a given submission.

### Reservations: ZSet

The data definiton for **(1)** must support a priority-based ordering of jobs and contain information to be used in **(2)**.

Redis' `ZSet` data structure is an ordered set with keys sorted by a given _score_ value (in practice, this is more usefully typed as an `OrderedMap<string, number>`). This can be utilized to create a priority queue of IDs to be popped off when a grading VM is ready to extract a new job.

```
ZSet Reservations => {
  <"team" | "user">.<id>.nonce: release_time
  <"immediate">.<GradingJobKey>.nonce: release_time
}
```

The set is mapped to the key `Reservations`, and each `ZSet` key is a unique identifier with either a user, team, or submission ID needed for retrieving the associated grading job. Keys receive a score equivalent to the timestamp of when they should be released for grading.

Each `ZSet` key also has a _nonce_, which is used to ensure students spamming the queue with multiple jobs reserve a corresponding spot. This nonce is the timestamp of when the job was enqueued.

`GradingJob`s are enqueued to be processed based on a given priority OR to be processed immediately. In the latter case, the `ZSet` key is composed of a **`GradingJobKey`, which is a `JSONString` generated by Bottlenose**. `GradingJobKey`s are opaque to Orca, and are only used to serve as a unique identifier of a `GradingJob`.

### SubmitterInfo: List

Orca stores the `GradingJobKey`s for a user/team's most recently enqueued jobs in a Stack. Orca implements "Last In First Out" behavior so that the most recent job, which is expected to yield the most useful feedback on a submission, will be graded first.

This can be implemented with a Redis `List`, where the list is mapped to a key containing the given user/team ID.

```
List SubmitterInfo.<"team" | "user">.<team_id | user_id> => [ job_key_0, job_key_1, ..., job_key_n ]
```

Order of the queue is maintained by only ever prepending job keys and popping the first one off the list.

### GradingJobKey -> GradingJob

`GradingJob` objects are individually mapped to a `GradingJobKey` inside Redis.

```
String <GradingJobKey> => GradingJob
```

Only one `GradingJob` exists per `GradingJobKey` so that the most recent grading script specifications provided by a professor are used for grading. For instance, if a student submits and a professor updates the test files for an assignment and clicks "regrade" for the student, this will update the grading job under that `GradingJobKey` such that when the student job gets graded, it will run with the updated specs.

### [BONUS] Nonces: Set

For optimization purposes, users may need to know what nonces are in use by a collation type/id in the Reservations `ZSet`.

These nonces are stored under the key `Nonces.<collation_type>.<collation_id>`.

## Web Server: Adding a Job to the Queue

Adding a job to the queue is a create-or-update function. If a job is already seen to be in the queue, then the job object will be updated but nothing will be added to the queue.

In the create case, Orca will queue up grading jobs based on their user ID or team ID. The given `GradingJob` object will contain a `GradingJobKey`, and the submission ID for this object will be pushed onto the `SubmitterInfo` Stack using Redis' `LPUSH` operation, ensuring it is added to the front.

`GradingJob`s sent from Bottlenose will contain a _priority_, which is a delay to be placed on a job. For now, assume `priority = (# of subs in last 15 mins) * 1 min`.

```typescript
LIFETIME_BUFFER = 60 * 60 * 24; // A day in seconds.

function createOrUpdateGradingJob(job: GradingJob) {
  const arrivalTime = time.now();
  if (!jobInQueue(job)) enqueueJob(job, arrivalTime);
  SET(job.key, job);
}

function jobInQueue({ key }: GradingJob) {
  return EXISTS(key);
}

function calculateJobLifeTime(
  { priority, key }: GradingJob,
  arrivalTime: number
) {
  return Math.max(priority + arrival_time + life_time_buffer, EXPIRETIME(key));
}

function enqueueJob(
  { key, collation, priority }: GradingJob,
  arrivalTime: number
) {
  const nextTask = `${collation.type}.${collation.id}`;
  const nonce = priority + arrivalTime;
  RPUSH(`SubmitterInfo.${nextTask}`, key);
  ZADD('Reservations', `${nextTask}.${arrivalTime}`, nonce);
  SADD(`Nonces.${collation.type}.${collation.id}`, nonce);
}
```

This priority is used to calculate the lifetime of the `GradingJobKey` in Redis, where this value is the maximum of the current `GradingJobKey`'s lifetime and the sum of priority, arrival time, and a buffer of one day. Orca uses Redis' expiration feature as a way to ensure items in the queue are cleaned up rather than implementing a constantly-running task. `SubmitterInfo` objects do not get an exprie time because Redis `List` structures get deleted upon becoming empty.

The priority is also used to calculate the `ZSet` score of the job: the sum of arrival time and the priority value.

The nonce of the reservation is cached for other update functionality.

## Web Server: Adding a Job for Immediate Grading

A professor may want to submit a job for immediate grading in the event they change the original test criteria.

While it's possible to place a job at the front of the line for a student/team by giving it a priority of 0, jobs may be added afterwards and thus a regrade attempt may be waiting for an arbitrarily long time.

Jobs added to the queue for immediate grading are added to the `Reservations` `ZSet` using its `GradingJobKey` (from the `key` attribute) instead of the team or user ID. This allows the job to bypass the `SubmitterInfo` list, ensuring that it cannot be cut in line.

```typescript
function createOrUpdateImmediateJob(job: GradingJob) {
  if (!jobInQueue(job)) createImmediateJob(job);
  SET(job.key, job);
  if (nonImmediateJobExists(job)) {
    removeNonImmediateJob(job);
    createImmediateJob(job);
  }
}

function nonImmediateJobExists({ key, collation }: GradingJob) {
  for (jobKey in LRANGE(`SubmitterInfo.${collation.type}.${collation.id}`)) {
    if (jobKey === key) return true;
  }
  return false;
}

function removeNonImmediateJob({ collation }: GradingJob) {
  LREM(`SubmitterInfo.${collation.type}.${collation.id}`);
  SPOP(`Nonces.${collation.type}.${collation.id}`);
  ZREM('Reservations', `${collation.type}.${collation.id}`);
}

function createImmediateJob(job: GradingJob) {
  arrival_time = time.now();
  ZSET(
    Reservations,
    `immediate.${GradingJob.key}`,
    arrival_time + GradingJob.priority
  );
}
```

Bottlenose guarantees that all jobs submitted for immediate grading will have a priority of 0.

## Web Server: Moving a Job in the Queue

Jobs in the queue may either be:

- Moved to the back of the queue.
- Moved to the front of the queue.

```typescript
enum MoveJobAction {
  RELEASE = 'release',
  DELAY = 'delay',
}

interface MoveJobRequest {
  nonce: number;
  job_key: JSONString;
  move_action: MoveJobAction;
  collation: Collation;
}
```

Moving a job requires its unique key, the nonce used in the job's corresponding `Reservations` `ZSet` key, the type of action to be taken, and either the team ID or user ID of the job. Jobs submitted for immediate grading cannot be moved.

```typescript
function moveJob(req: JobMoveRequest) {
  const { nonce, job_key, move_action, collation } = req;
  let new_priority: number;
  switch (move_action) {
    case MoveJobAction.RELEASE:
      new_priority = releaseJob(req);
      break;
    case MoveJobAction.DELAY:
      new_priority = 0;
      break;
    default:
      throw Error();
  }
  ZADD(
    'Reservations',
    `${req.user_id ? 'user' : 'team'}.${req.collation.type || req.team_id}.${
      req.nonce
    }`,
    new_priority
  );
}

const MOVE_TO_BACK_BUFFER = 10; // seconds

function delayJob(req: JobMoveReuquest) {
  [last_job, last_priority] = ZRANGE('Reservations', -1, -1, WITHSCORES); // Gets job at back of queue
  new_priority = last_priority + MOVE_TO_BACK_BUFFER;
  new_lifetime = new_priority + LIFE_TIME_BUFFER;
  job = GET(req.job_key);
  EXPIRE_AT(req.job_key, new_lifetime);
  return new_priority;
}
```

A job is moved to the back of the queue by assigning it a new priority of `priorityOf(lastJobInQueue) + buffer`. The buffer is used to guaranteed that the given job will be placed at the back.

### Examples

- Release a job -> job at front of queue
- Delay a job -> job at back of queue
- Release job_1, release job_2 -> job_2 in front of job_1, job_1 in front of job_3...job_n
- Delay job_1, delay job_2 -> job_2 is behind job_1, job_1 is behind job_3...job_n

## Web Server: Deleting a Job from the Queue

A job can be deleted given its nonce in the `Reservations` `ZSet` and collation information if relevant.

```typescript
function deleteJob(
  job_key: string,
  nonce: number,
  collation: Collation? = undefined
) {
  if (collation) {
    LREM(`SubmitterInfo.${cType}.${cID}`, 1, job_key);
    ZREM('Reservations', [cType, cID, nonce].join('.'));
  } else {
    ZREM('Reservations', `immediate.${nonce}`);
  }
}
```

Non-immediate jobs have their information ejected from both `Reservations` and the proper `SubmitterInfo` list.

## Grading VM: Extracting Job From Queue

Grading jobs are popped from the queue using their associated `GradingJobKey`.

```typescript
next_task = ZPOPMIN('Reservations')
if (next_task STARTS WITH "immediate") {
	_, job_key, _ = next_task.split(".")
} else {
	id_type, id, _ = next_task.split(".")
	job_key = LPOP(`SubmitterInfo.${id_type}.${id}`)
}
grading_info = GET(job_key)
```

This is either obtained directly by popping off the first item from `Reservations`, or by popping the first submission ID off of `SubmitterInfo` given the team/user ID from `Reservations`.
