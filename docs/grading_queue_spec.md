# Grading Queue: A Redis-based Architecture

The Orca Grading Queue is ephemeral in nature, where data has a lifetime and will never be persisted. Redis was the chosen tool to implement the Grading Queue, as an in-memory storage system with quick access to its elements.

## Data Definitions

A full implementation of the grading queue requires three pieces of functionality:

1. Knowing when a job is ready to be extracted and graded.
2. Retrieving the next job to be graded for a given team or user.
3. Obtaining the correct `GradingJob` object.

### Reservations: ZSet

The data definiton for **(1)** must support a priority-based ordering of jobs and contain information to be used in **(2)**.

Redis' `ZSet` data structure is an ordered set with keys sorted by a given _score_ value (in practice, this is more usefully typed as an `OrderedMap<string, number>`). This can be utilized to create a priority queue of IDs to be popped off when a grading VM is ready to extract a new job.

```
ZSet Reservations => {
  <"team" | "user">.<id>.nonce: release_time
  <"immediate">.<GradingJobKey>.nonce: release_time
}
```

The set is mapped to the key `Reservations`, and each `ZSet` key is a unique identifier with either a user, team, or submission ID needed for retrieving the associated grading job. Keys receive a score equivalent to the timestamp of when they should be released for grading.

Each `ZSet` key also has a _nonce_, which is used to ensure students spamming the queue with multiple jobs reserve a corresponding spot. This nonce is the timestamp of when the job was enqueued.

`GradingJob`s are enqueued to be processed based on a given priority OR to be processed immediately. In the latter case, the `ZSet` key is composed of a **`GradingJobKey`, which is a `JSONString` generated by Bottlenose**. `GradingJobKey`s are opaque to Orca, and are only used to serve as a unique identifier of a `GradingJob`.

### SubmitterInfo: List

Orca stores the `GradingJobKey`s for a user/team's most recently enqueued jobs in a Stack. Orca implements "Last In First Out" behavior so that the most recent job, which is expected to yield the most useful feedback on a submission, will be graded first.

This can be implemented with a Redis `List`, where the list is mapped to a key containing the given user/team ID.

```
List SubmitterInfo.<"team" | "user">.<team_id | user_id> => [ job_key_0, job_key_1, ..., job_key_n ]
```

Order of the queue is maintained by only ever prepending job keys and popping the first one off the list.

### GradingJobKey -> GradingJob

`GradingJob` objects are individually mapped to a `GradingJobKey` inside Redis.

```
String <GradingJobKey> => GradingJob
```

Only one `GradingJob` exists per `GradingJobKey` so that the most recent grading script specifications provided by a professor are used for grading. For instance, if a student submits and a professor updates the test files for an assignment and clicks "regrade" for the student, this will update the grading job under that `GradingJobKey` such that when the student job gets graded, it will run with the updated specs.

### [BONUS] Nonces: Set

For optimization purposes, users may need to know what nonces are in use by a collation type/id in the Reservations `ZSet`.

These nonces are stored under the key `Nonces.<collation_type>.<collation_id>`.

## Queue Operations

All operations are performed by either the web server or the grading VM.

**NOTE**: Any functionality implemented must use Redlock to ensure Redis resources are not accessed by two machines at the same time.

### Web Server: Adding a Job to the Queue

Adding a job to the queue is a create-or-update function. If a job is already seen to be in the queue, then the job object will be updated but nothing will be added to the queue.

In the create case, Orca will queue up grading jobs based on their user ID or team ID. The given `GradingJob` object will contain a `GradingJobKey`, and the submission ID for this object will be pushed onto the `SubmitterInfo` Stack using Redis' `LPUSH` operation, ensuring it is added to the front.

`GradingJob`s sent from Bottlenose will contain a _priority_, which is a delay to be placed on a job. For now, assume `priority = (# of subs in last 15 mins) * 1 min`.

```typescript
LIFETIME_BUFFER = 60 * 60 * 24; // A day in seconds.

function createOrUpdateGradingJob(job: GradingJob) {
  const arrivalTime = time.now();
  if (!jobInQueue(job)) enqueueJob(job, arrivalTime);
  SET(job.key, job);
}

function jobInQueue({ key }: GradingJob) {
  return EXISTS(key);
}

function calculateJobLifeTime(
  { priority, key }: GradingJob,
  arrivalTime: number
) {
  return Math.max(priority + arrival_time + life_time_buffer, EXPIRETIME(key));
}

function enqueueJob(
  { key, collation, priority }: GradingJob,
  arrivalTime: number
) {
  const nextTask = `${collation.type}.${collation.id}`;
  const nonce = priority + arrivalTime;
  RPUSH(`SubmitterInfo.${nextTask}`, key);
  ZADD('Reservations', `${nextTask}.${arrivalTime}`, nonce);
  SADD(`Nonces.${collation.type}.${collation.id}`, nonce);
}
```

This priority is used to calculate the lifetime of the `GradingJobKey` in Redis, where this value is the maximum of the current `GradingJobKey`'s lifetime and the sum of priority, arrival time, and a buffer of one day. Orca uses Redis' expiration feature as a way to ensure items in the queue are cleaned up rather than implementing a constantly-running task. `SubmitterInfo` objects do not get an exprie time because Redis `List` structures get deleted upon becoming empty.

The priority is also used to calculate the `ZSet` score of the job: the sum of arrival time and the priority value.

The nonce of the reservation is cached for other update functionality.

### Web Server: Adding a Job for Immediate Grading

A professor may want to submit a job for immediate grading in the event they change the original test criteria.

While it's possible to place a job at the front of the line for a student/team by giving it a priority of 0, jobs may be added afterwards and thus a regrade attempt may be waiting for an arbitrarily long time. For this reason, if a non-immediate job already exists, it is replaced with a new immediate job.

Jobs added to the queue for immediate grading are added to the `Reservations` `ZSet` using its `GradingJobKey` (from the `key` attribute) instead of the team or user ID. This allows the job to bypass the `SubmitterInfo` list, ensuring that it cannot be cut in line.

```typescript
function createOrUpdateImmediateJob(job: GradingJob) {
  if (!jobInQueue(job)) createImmediateJob(job);
  SET(job.key, job);
  if (nonImmediateJobExists(job)) upgradeJob(job: GradingJob);
}

function nonImmediateJobExists({ key, collation }: GradingJob) {
  for (jobKey in LRANGE(`SubmitterInfo.${collation.type}.${collation.id}`)) {
    if (jobKey === key) return true;
  }
  return false;
}

function upgradeJob(job: GradingJob) {
  removeNonImmediateJob(job);
  createImmediateJob(job);
}

function removeNonImmediateJob({ collation }: GradingJob) {
  LREM(`SubmitterInfo.${collation.type}.${collation.id}`);
  SPOP(`Nonces.${collation.type}.${collation.id}`);
  ZREM('Reservations', `${collation.type}.${collation.id}`);
}

function createImmediateJob(job: GradingJob) {
  arrival_time = time.now();
  ZSET(
    Reservations,
    `immediate.${GradingJob.key}`,
    arrival_time + GradingJob.priority
  );
}
```

Bottlenose guarantees that all jobs submitted for immediate grading will have a priority of 0.

### Web Server: Moving a Job in the Queue

Jobs in the queue may either be:

- Moved to the back of the queue.
- Moved to the front of the queue.

```typescript
enum MoveJobAction {
  RELEASE = 'release',
  DELAY = 'delay',
}

interface MoveJobRequest {
  nonce: number;
  jobKey: JSONString;
  moveAction: MoveJobAction;
  collation?: Collation;
}
```

Moving a job requires its unique key, the nonce used in the job's corresponding `Reservations` `ZSet` key, the type of action to be taken, and collation data. Jobs submitted for immediate grading cannot be moved.

```typescript
function moveJob(req: JobMoveRequest) {
  const { nonce, jobKey, moveAction, collation } = req;
  if (!collation) return;
  switch (move_action) {
    case MoveJobAction.RELEASE:
      const job = GET(jobKey);
      upgradeJob(job);
      break;
    case MoveJobAction.DELAY:
      delayJob(req);
      break;
    default:
      throw Error();
  }
}

const MOVE_TO_BACK_BUFFER = 10; // seconds

function delayJob(req: JobMoveReuquest) {
  [last_job, last_priority] = ZRANGE('Reservations', -1, -1, WITHSCORES); // Gets job at back of queue
  const new_priority = last_priority + MOVE_TO_BACK_BUFFER;
  ZADD(
    'Reservations',
    `${req.collation.type}.${req.collation.id}.${req.nonce}`,
    new_priority
  );
  const subInfoKey = `SubmitterInfo.${req.collation.type}.${req.collation.id}`;
  LREM(subInfoKey, req.jobKey);
  RPUSH(subInfoKey, req.jobKey);
  return new_priority;
}
```

A job is moved to the back of the queue by assigning it a new priority of `priorityOf(lastJobInQueue) + buffer` as its score in `Reservations`. The buffer is used to guarantee that the given job will be placed at the back. The job is also placed at the back of `SubmitterInfo`.

Jobs are moved to the front of the queue by being replaced with an immediate job, ensuring they cannot be skipped.

#### Examples

- Release a job -> job at front of queue
- Delay a job -> job at back of queue
- Release job_1, release job_2 -> job_2 in front of job_1, job_1 in front of job_3...job_n
- Delay job_1, delay job_2 -> job_2 is behind job_1, job_1 is behind job_3...job_n

### Web Server: Deleting a Job from the Queue

A job can be deleted given its nonce in the `Reservations` `ZSet` and collation information if relevant.

```typescript
function deleteJob(
  job_key: string,
  nonce: number,
  collation: Collation? = undefined
) {
  if (collation) {
    LREM(`SubmitterInfo.${cType}.${cID}`, 1, job_key);
    ZREM('Reservations', [cType, cID, nonce].join('.'));
    SREM(`Nonces.${cType}.${cID}`, nonce);
  } else {
    ZREM('Reservations', `immediate.${nonce}`);
  }
}
```

All jobs have their data ejected from `Reservations`. Non-immediate jobs have data also have data removed from both the proper `Nonces` and `SubmitterInfo` set and list, respectively.

### Grading VM: Extracting Job From Queue

Grading jobs are popped from the queue using their associated `GradingJobKey`.

```typescript
const nextTask = ZPOPMIN('Reservations');
const nextTaskInfo = next_task.split('.');

let jobKey, collationType, collationID, nonce;
if (nextInfo[0] === 'immediate') {
  [_, jobKey] = nextTaskInfo;
} else {
  [collationType, collationID, nonce] = nextTaskInfo;
  SREM(`Nonces.${collationType}.${collationID}`, nonce);
  jobKey = LPOP(`SubmitterInfo.${collationType}.${collationID}`);
}
const gradingJob = GETDEL(jobKey);
```

This is either obtained directly by popping off the first item from `Reservations`, or by using the collation data from the reservation to pop the first job key off of `SubmitterInfo`. All data pointing to the job is deleted, either through a "pop" or deletion function.
