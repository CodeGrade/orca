# Redis Grading Queue Set Up

Explanation for why Redis was the choice for the queue.

## Data Definitions

A full implementation of the grading queue requires three pieces of functionality:

1. Knowing when a job is ready to be extracted and graded.
2. Retrieving the next submission to be graded for a given team or user.
3. Obtaining the `GradingJob` object for a given submission.

### Reservations: ZSet

The data definiton for **(1)** must support a priority-based ordering of jobs and contain information to be used in **(2)**.

Redis' `ZSet` data structure is an ordered set with keys sorted by a given _score_ value (in practice, this is more usefully typed as an `OrderedMap<string, number>`). This can be utilized to create a priority queue of IDs to be popped off when a grading VM is ready to extract a new job.

```
ZSet Reservations => {
  <"team" | "user">.<id>.nonce: release_time
  <"immediate">.<GradingJobKey>.nonce: release_time
}
```

The set is mapped to the key `Reservations`, and each `ZSet` key is a unique identifier with either a user, team, or submission ID needed for retrieving the associated grading job. Keys receive a score equivalent to the timestamp of when they should be released for grading.

Each `ZSet` key also has a _nonce_, which is used to ensure students spamming the queue with multiple jobs reserve a corresponding spot. This nonce is the timestamp of when the job was enqueued.

`GradingJob`s are enqueued to be processed based on a given priority OR to be processed immediately. In the latter case, the `ZSet` key is composed of a **`GradingJobKey`, which is a `JSONString` generated by Bottlenose**. `GradingJobKey`s are opaque to Orca, and are only used to serve as a unique identifier of a `GradingJob`.

### SubmitterInfo: List

Orca stores the `GradingJobKey`s for a user/team's most recently enqueued jobs in a Stack. Orca implements "Last In First Out" behavior so that the most recent job, which is expected to yield the most useful feedback on a submission, will be graded first.

This can be implemented with a Redis `List`, where the list is mapped to a key containing the given user/team ID.

```
List SubmitterInfo.<"team" | "user">.<team_id | user_id> => [ job_key_0, job_key_1, ..., job_key_n ]
```

Order of the queue is maintained by only ever prepending job keys and popping the first one off the list.

### GradingJobKey -> GradingJob

`GradingJob` objects are individually mapped to a `GradingJobKey` inside Redis.

```
String <GradingJobKey> => GradingJob
```

Only one `GradingJob` exists per `GradingJobKey` so that the most recent grading script specifications provided by a professor are used for grading. For instance, if a student submits and a professor updates the test files for an assignment and clicks "regrade" for the student, this will update the grading job under that `GradingJobKey` such that when the student job gets graded, it will run with the updated specs.

## Web Server: Adding a Job to the Queue

Orca will queue up grading jobs based on their user ID or team ID. The given `GradingJob` object will contain a `GradingJobKey`, and the submission ID for this object will be pushed onto the `SubmitterInfo` Stack using Redis' `LPUSH` operation, ensuring it is added to the front.

`GradingJob`s sent from Bottlenose will contain a _priority_, which is a delay to be placed on a job. For now, assume `delay = (# of subs in last 15 mins) * 1 min`.

```typescript
LIFETIME_BUFFER = 60 * 60 * 24; // A day in seconds.

function createOrUpdateGradingJob(job: GradingJob) {
  arrivalTime = time.now();
  lifetime = calculateJobLifetime(job, arrivalTime);
  if (!jobInQueue(job)) {
    setEnqueuedJobDetails(job, lifetime);
    enqueueJob(job, arrivalTime);
  } else {
    setEnqueuedJobDetails(job);
  }
}

function jobInQueue({ key }: GradingJob) {
  return EXISTS(key);
}

function calculateJobLifeTime(
  { priority, key }: GradingJob,
  arrivalTime: number
) {
  return Math.max(priority + arrival_time + life_time_buffer, EXPIRETIME(key));
}

function setEnqueuedJobDetails(job: GradingJob, lifetime?: number) {
  if (lifetime !== null || lifetime !== undefined) {
    SET(job.key, job, (ex = lifetime));
  } else {
    SET(job.key, job);
  }
}

function enqueueJob(
  { key, collation, priority }: GradingJob,
  arrivalTime: number
) {
  nextTask = `${collation.type}.${collation.id}`;
  RPUSH(`SubmitterInfo.${nextTask}`, key);
  ZADD(Reservations, `${nextTask}.${arrivalTime}`, priority + arrivalTime);
}
```

This priority is used to calculate the lifetime of the `GradingJobKey` in Redis, where this value is the maximum of the current `GradingJobKey`'s lifetime and the sum of priority, arrival time, and a buffer of one day. Orca uses Redis' expiration feature as a way to ensure items in the queue are cleaned up rather than implementing a constantly-running task. `SubmitterInfo` objects do not get an exprie time because Redis `List` structures get deleted upon becoming empty.

The priority is also used to calculate the `ZSet` score of the job, which is just the sum of arrival time and the priority value.

## Web Server: Adding a Job for Immediate Grading

A professor may want to submit a job for immediate grading in the event they change the original test criteria.

While it's possible to place a job at the front of the line for a student/team by giving it a priority of 0, jobs may be added afterwards and thus a regrade attempt may be waiting for an arbitrarily long time.

Jobs added to the queue for immediate grading are added to the `Reservations` `ZSet` using its `GradingJobKey` (from the `key` attribute) instead of the team or user ID. This allows the job to bypass the `SubmitterInfo` list, ensuring that it cannot be cut in line.

```typescript
function nonImmediateJobExists({ key, collation }: GradingJob) {
  for (jobKey in LRANGE(`SubmitterInfo.${collation.type}.${collation.id}`)) {
    if (jobKey === key) return true;
  }
  return false;
}

function createOrUpdateImmediateJob(job: GradingJob) {}

function createImmediateJob(job: GradingJob) {
  lifetime_buffer = 60 * 60 * 24; // Add buffer of 1 day to expiry.
  arrival_time = time.now();
  lifetime = Math.max(
    arrival_time + lifetime_buffer,
    EXPIRETIME(GradingJob.key)
  );
  SET(GradingJob.key, GradingJob, (ex = lifetime));
  ZSET(
    Reservations,
    `immediate.${GradingJob.key}.${arrival_time}`,
    GradingJob.priority
  );
}
```

Bottlenose guarantees that all jobs submitted for immediate grading will have a priority of 0.

## Web Server: Moving a Job in the Queue

Jobs in the queue may either be:

- Moved to the back of the queue.
- Moved to the front of the queue.

```typescript
enum MoveJobAction {
  RELEASE = 'release',
  DELAY = 'delay',
}

interface MoveJobRequest {
  nonce: number;
  job_key: JSONString;
  move_action: MoveJobAction;
  collation: Collation;
}
```

Moving a job requires its unique key, the nonce used in the job's corresponding `Reservations` `ZSet` key, the type of action to be taken, and either the team ID or user ID of the job. Jobs submitted for immediate grading cannot be moved.

```typescript
function moveJob(req: JobMoveRequest) {
  const { nonce, job_key, move_action, collation } = req;
  let new_priority: number;
  switch (move_action) {
    case MoveJobAction.RELEASE:
      new_priority = releaseJob(req);
      break;
    case MoveJobAction.DELAY:
      new_priority = 0;
      break;
    default:
      throw Error();
  }
  ZADD(
    'Reservations',
    `${req.user_id ? 'user' : 'team'}.${req.collation.type || req.team_id}.${
      req.nonce
    }`,
    new_priority
  );
}

const MOVE_TO_BACK_BUFFER = 10; // seconds

function delayJob(req: JobMoveReuquest) {
  [last_job, last_priority] = ZRANGE('Reservations', -1, -1, WITHSCORES); // Gets job at back of queue
  new_priority = last_priority + MOVE_TO_BACK_BUFFER;
  new_lifetime = new_priority + LIFE_TIME_BUFFER;
  job = GET(req.job_key);
  EXPIRE_AT(req.job_key, new_lifetime);
  return new_priority;
}
```

A job is moved to the back of the queue by assigning it a new priority of `priorityOf(lastJobInQueue) + buffer`. The buffer is used to guaranteed that the given job will be placed at the back.

### Examples

- Release a job -> job at front of queue
- Delay a job -> job at back of queue
- Release job_1, release job_2 -> job_2 in front of job_1, job_1 in front of job_3...job_n
- Delay job_1, delay job_2 -> job_2 is behind job_1, job_1 is behind job_3...job_n

## Web Server: Deleting a Job from the Queue

A job can be deleted given its nonce in the `Reservations` `ZSet` and collation information if relevant.

```typescript
function deleteJob(
  job_key: string,
  nonce: number,
  collation: Collation? = undefined
) {
  if (collation) {
    LREM(`SubmitterInfo.${cType}.${cID}`, 1, job_key);
    ZREM('Reservations', [cType, cID, nonce].join('.'));
  } else {
    ZREM('Reservations', `immediate.${nonce}`);
  }
}
```

Non-immediate jobs have their information ejected from both `Reservations` and the proper `SubmitterInfo` list.

## Grading VM: Extracting Job From Queue

Grading jobs are popped from the queue using their associated `GradingJobKey`.

```typescript
next_task = ZPOPMIN('Reservations')
if (next_task STARTS WITH "immediate") {
	_, job_key, _ = next_task.split(".")
} else {
	id_type, id, _ = next_task.split(".")
	job_key = LPOP(`SubmitterInfo.${id_type}.${id}`)
}
grading_info = GET(job_key)
```

This is either obtained directly by popping off the first item from `Reservations`, or by popping the first submission ID off of `SubmitterInfo` given the team/user ID from `Reservations`.
