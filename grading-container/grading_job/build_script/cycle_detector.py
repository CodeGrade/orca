from typing import Dict, List, Set

from validations.grading_job_json_types import GradingScriptCommandJSON


class CycleDetector:

  @staticmethod
  def contains_cycle(json_script: List[GradingScriptCommandJSON]):
    """
    Given a list of GradingScriptCommandJSON, apply Kosaraju's algorithm
    to determine if a graph generated by the commands contains a cycle.
    """
    # First Iteration:
    unvisited: Set[int] = set([i for i in range(len(json_script))])
    command_stack = CycleDetector.generate_command_stack(json_script, unvisited)
    # Second Iteration:
    assignments: Dict[int, int] = dict()
    while len(command_stack) > 0:
      vertex = command_stack.pop()
      CycleDetector.assign_components(json_script, vertex, vertex, assignments)
    # Check for cycles:
    return CycleDetector.count_number_of_strongly_connected_components(assignments) > 1

  @staticmethod
  # Integral piece of the algorithm; separated out for testability.
  def generate_command_stack(json_script: List[GradingScriptCommandJSON], unvisited: Set[int]) \
    -> List[int]:
    command_stack: List[int] = []
    for u in range(len(json_script)):
      CycleDetector.visit_command(json_script, unvisited, command_stack, u)
    return command_stack

  @staticmethod
  def visit_command(json_script: List[GradingScriptCommandJSON], unvisited: Set[int], 
    command_stack: List[int], vertex: int) -> None:
    if vertex in unvisited:
      unvisited.remove(vertex)
      command: GradingScriptCommandJSON = json_script[vertex]
      if command["on_fail"] != "abort":
        on_fail_vertex = int(command["on_fail"])
        CycleDetector.visit_command(json_script, unvisited, command_stack, 
          on_fail_vertex)
      if command["on_complete"] != "output":
        on_complete_vertex = int(command["on_complete"])
        CycleDetector.visit_command(json_script, unvisited, command_stack, 
          on_complete_vertex)
      command_stack.append(vertex)

  @staticmethod
  def assign_components(json_script: List[GradingScriptCommandJSON], vertex: int, 
    root: int, assignments: Dict[int, int]) -> None:
    if vertex not in assignments:
      assignments[vertex] = root
      command = json_script[vertex]
      if command["on_fail"] != "abort":
        on_fail_vertex = int(command["on_fail"])
        CycleDetector.assign_components(json_script, on_fail_vertex, root, assignments)
      if command["on_complete"] != "output":
        on_complete_vertex = int(command["on_complete"])
        CycleDetector.assign_components(json_script, on_complete_vertex, root, assignments)
  
  @staticmethod
  def count_number_of_strongly_connected_components(assigned_components: Dict[int, int]) -> int:
    num_strong_components = 0
    for item in assigned_components.items():
      vertex, root = item
      if vertex == root:
        num_strong_components += 1
    return num_strong_components

    
  
      
