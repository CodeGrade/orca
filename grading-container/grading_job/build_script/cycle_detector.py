from typing import Dict, List, Set
from grading_job.build_script.json_helpers.grading_script_command import is_bash_command, is_conditional_command
from validations.grading_job_json_types import GradingScriptCommandJSON

class CycleDetector:

  @staticmethod
  def contains_cycle(json_script: List[GradingScriptCommandJSON]):
    """
    Given a list of GradingScriptCommandJSON, apply Kosaraju's algorithm
    to determine if a graph generated by the commands contains a cycle.
    """
    # Check for self-referential commands (i.e., on_* points to same command)
    for i in range(len(json_script)):
      json_command = json_script[i]
      if CycleDetector.cmd_has_self_ref(json_command, i):
        return True
    # First DFS Iteration:
    unvisited: Set[int] = set([i for i in range(len(json_script))])
    command_stack = CycleDetector.generate_command_stack(json_script, unvisited)
    # Second DFS Iteration:
    assignments: Dict[int, int] = dict()
    while len(command_stack) > 0:
      vertex = command_stack.pop()
      CycleDetector.assign_components(json_script, vertex, vertex, assignments)
    # Check for cycles between nodes:
    num_scc = CycleDetector.count_number_of_strongly_connected_components(assignments)
    return num_scc != len(json_script)
  
  @staticmethod
  def cmd_has_self_ref(json_command: GradingScriptCommandJSON, index: int) -> bool:
    return (is_conditional_command(json_command) and CycleDetector.conditional_cmd_has_self_ref(json_command, index)) \
      or (is_bash_command(json_command) and CycleDetector.bash_cmd_has_self_ref(json_command, index))

  @staticmethod
  def conditional_cmd_has_self_ref(json_command: GradingScriptCommandJSON, index: int) -> bool:
    return json_command["on_false"] == index or json_command["on_true"] == index

  def bash_cmd_has_self_ref(json_command: GradingScriptCommandJSON, index: int) -> bool:
    return (json_command["on_complete"] != "output" and \
      int(json_command["on_complete"]) == index) or \
      (json_command["on_fail"] != "abort" and \
      int(json_command["on_fail"]) == index)

  @staticmethod
  # Integral piece of the algorithm; separated out for testability.
  def generate_command_stack(json_script: List[GradingScriptCommandJSON], unvisited: Set[int]) \
    -> List[int]:
    command_stack: List[int] = []
    for u in range(len(json_script)):
      CycleDetector.visit_command(json_script, unvisited, command_stack, u)
    return command_stack

  @staticmethod
  def visit_command(json_script: List[GradingScriptCommandJSON], unvisited: Set[int], 
    command_stack: List[int], vertex: int) -> None:
    if vertex in unvisited:
      unvisited.remove(vertex)
      command: GradingScriptCommandJSON = json_script[vertex]
      if is_conditional_command(command):
        CycleDetector.visit_conditional_command(json_script, unvisited, command_stack, vertex)
      else:
        CycleDetector.visit_bash_command(json_script, unvisited, command_stack, vertex)
      command_stack.append(vertex)
  
  @staticmethod
  def visit_conditional_command(json_script: List[GradingScriptCommandJSON], unvisited: Set[int],
    command_stack: List[int], vertex: int) -> None:
    json_command = json_script[vertex]
    on_false_vertex: int = json_command["on_false"]
    CycleDetector.visit_command(json_script, unvisited, command_stack, 
      on_false_vertex)
    on_true_vertex: int = json_command["on_true"]
    CycleDetector.visit_command(json_script, unvisited, command_stack,
      on_true_vertex)
  
  @staticmethod
  def visit_bash_command(json_script: List[GradingScriptCommandJSON], unvisited: Set[int], 
    command_stack: List[int], vertex: int) -> None:
    json_command = json_script[vertex]
    if json_command["on_fail"] != "abort":
      fail_vertex = int(json_command["on_fail"])
      CycleDetector.visit_command(json_script, unvisited, command_stack, fail_vertex)
    if json_command["on_complete"] != "output":
      complete_vertex = int(json_command["on_complete"])
      CycleDetector.visit_command(json_script, unvisited, command_stack, complete_vertex)

  @staticmethod
  def assign_components(json_script: List[GradingScriptCommandJSON], vertex: int, 
    root: int, assignments: Dict[int, int]) -> None:
    if vertex not in assignments:
      assignments[vertex] = root
      command = json_script[vertex]
      if is_conditional_command(command):
        CycleDetector.assign_components_conditional_command(json_script, vertex, root, assignments)
      else:
        CycleDetector.assign_components_bash_command(json_script, vertex, root, assignments)
  
  @staticmethod
  def assign_components_conditional_command(json_script: List[GradingScriptCommandJSON], 
    vertex: int, root: int, assignments: Dict[int, int]) -> None:
    json_command = json_script[vertex]
    true_vertex: int = json_command["on_true"]
    CycleDetector.assign_components(json_script, true_vertex, root, assignments)
    false_vertex: int = json_command["on_false"]
    CycleDetector.assign_components(json_script, false_vertex, root, assignments)

  @staticmethod
  def assign_components_bash_command(json_script: List[GradingScriptCommandJSON],
    vertex: int, root: int, assignments: Dict[int, int]) -> None:
    json_command = json_script[vertex]
    if json_command["on_fail"] != "abort":
      fail_vertex = int(json_command["on_fail"])
      CycleDetector.assign_components(json_script, fail_vertex, root, assignments)
    if json_command["on_complete"] != "output":
      complete_vertex = int(json_command["on_complete"])
      CycleDetector.assign_components(json_script, complete_vertex, root, assignments)
    
  @staticmethod
  def count_number_of_strongly_connected_components(assigned_components: Dict[int, int]) -> int:
    num_strong_components = 0
    for item in assigned_components.items():
      vertex, root = item
      if vertex == root:
        num_strong_components += 1
    return num_strong_components

    
  
      
